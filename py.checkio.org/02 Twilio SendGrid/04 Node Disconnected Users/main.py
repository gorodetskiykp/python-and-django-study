"""
Добро пожаловать в GridLand. 
Все граждане здесь подключены через глобальную внутреннюю сеть, потому что основным способом общения является электронная почта. 
Строительство нового района всегда начинается с возведения вышки - районного центра. 
Все жители подключены к этой вышке, чтобы иметь возможность отправлять и получать электронные письма. 
Все вышки GridLand подключены, поэтому одна вышка может отправлять электронные письма между связанными вышками. 
Таким образом, независимо от того, насколько велик город, все пользователи могут отправлять сообщения друг другу до того момента, пока все вышки подключены.
Мэр GridLand использует эту сеть, чтобы в случае необходимости быстро отправлять экстренные сообщения всем гражданам. 
Но система не идеальна. В случае разрушения одной из вышек, все жители района, где она была возведена, могут остаться отключенными от этих экстренных емейл сообщений. 
Данное происшествие также может быть причиной повреждения связи в смежных районах, если их вышки не имеют других способов подключения. 
Чтобы разрешить данную проблему мэр использует почтовых голубей - старый метод отправки почты, который был изобретен до глобальной внутренней сети. 
Граждане, которые все еще подключены к сети, получают экстренные сообщения по электронной почте, но отключенные граждане получают их от этих голубей.
Ваша миссия - выяснить, сколько нужно голубей, если некоторые из вышек разрушены.
Входные данные: Четыре параметра: структура сети (в виде списка соединений между вышками), 
пользователи на каждой вышке (в виде dict, где ключи - имя вышки, а значения - количество пользователей), название вышки, отправляющей электронную почту, 
и список разрушенных вышек.
Выходные данные: Int. Количество пользователей, которые не получат экстренные сообщения.
Пример:

    disconnected_users([
        ['A', 'B'],
        ['B', 'C'],
        ['C', 'D']
    ], {
        'A': 10,
        'B': 20,
        'C': 30,
        'D': 40
    },
        'A', ['C']) == 70

    disconnected_users([
        ['A', 'B'],
        ['B', 'D'],
        ['A', 'C'],
        ['C', 'D']
    ], {
        'A': 10,
        'B': 0,
        'C': 0,
        'D': 40
    },
        'A', ['B']) == 0

    disconnected_users([
        ['A', 'B'],
        ['A', 'C'],
        ['A', 'D'],
        ['A', 'E'],
        ['A', 'F']
    ], {
        'A': 10,
        'B': 10,
        'C': 10,
        'D': 10,
        'E': 10,
        'F': 10
    },
        'C', ['A']) == 50
"""

def disconnected_users(net, users, source, crushes):
    normal = set()
    if source not in crushes:
        normal.add(source)
    checked = set()
    while normal:
        current_source = normal.pop()
        for pair in net:
            if current_source in pair:
                normal_point = set(pair).difference(current_source).pop()
                if normal_point not in crushes and normal_point not in checked:
                    normal.add(normal_point)
        checked.add(current_source)

    return sum([users_qnt for point, users_qnt in users.items() if point not in checked])

if __name__ == '__main__':
    print(disconnected_users([["A","B"],["B","C"],["C","D"]],{"A":10,"B":20,"C":30,"D":40},"A",["A"]))
    # net = [
    #         ['A', 'B'],
    #         ['B', 'C'],
    #         ['C', 'D']
    #     ]

    # users = {
    #         'A': 10,
    #         'B': 20,
    #         'C': 30,
    #         'D': 40
    #     }

    # source = 'A'

    # crushes = ['C']
    
    # print(disconnected_users(net, users, source, crushes))
    # assert disconnected_users([
    #     ['A', 'B'],
    #     ['B', 'C'],
    #     ['C', 'D']
    # ], {
    #     'A': 10,
    #     'B': 20,
    #     'C': 30,
    #     'D': 40
    # },
    #     'A', ['C']) == 70, "First"

    # assert disconnected_users([
    #     ['A', 'B'],
    #     ['B', 'D'],
    #     ['A', 'C'],
    #     ['C', 'D']
    # ], {
    #     'A': 10,
    #     'B': 0,
    #     'C': 0,
    #     'D': 40
    # },
    #     'A', ['B']) == 0, "Second"

    # assert disconnected_users([
    #     ['A', 'B'],
    #     ['A', 'C'],
    #     ['A', 'D'],
    #     ['A', 'E'],
    #     ['A', 'F']
    # ], {
    #     'A': 10,
    #     'B': 10,
    #     'C': 10,
    #     'D': 10,
    #     'E': 10,
    #     'F': 10
    # },
    #     'C', ['A']) == 50, "Third"